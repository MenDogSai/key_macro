using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using static System.Windows.Forms.VisualStyles.VisualStyleElement.TaskbarClock;

namespace key_macro
{
    [Flags]
    public enum MOUSEEVENTF : uint
    {
        NONE = 0,
        /// <summary>
        /// Movement occurred.
        /// </summary>
        MOUSEEVENTF_MOVE = 0x0001,
        /// <summary>
        /// The left button was pressed.
        /// </summary>
        MOUSEEVENTF_LEFTDOWN = 0x0002,
        /// <summary>
        /// The left button was released.
        /// </summary>
        MOUSEEVENTF_LEFTUP = 0x0004,
        /// <summary>
        /// The right button was pressed.
        /// </summary>
        MOUSEEVENTF_RIGHTDOWN = 0x0008,
        /// <summary>
        /// The right button was released.
        /// </summary>
        MOUSEEVENTF_RIGHTUP = 0x0010,
        /// <summary>
        /// The middle button was pressed.
        /// </summary>
        MOUSEEVENTF_MIDDLEDOWN = 0x0020,
        /// <summary>
        /// The middle button was released.
        /// </summary>
        MOUSEEVENTF_MIDDLEUP = 0x0040,
        /// <summary>
        /// An X button was pressed.
        /// </summary>
        MOUSEEVENTF_XDOWN = 0x0080,
        /// <summary>
        /// An X button was released.
        /// </summary>
        MOUSEEVENTF_XUP = 0x0100,
        /// <summary>
        /// The wheel was moved, if the mouse has a wheel. The amount of movement is specified in mouseData.
        /// </summary>
        MOUSEEVENTF_WHEEL = 0x0800,
        /// <summary>
        /// The wheel was moved horizontally, if the mouse has a wheel. The amount of movement is specified in mouseData.
        /// </summary>
        MOUSEEVENTF_HWHEEL = 0x01000,
        /// <summary>
        /// Maps coordinates to the entire desktop. Must be used with MOUSEEVENTF_ABSOLUTE.
        /// </summary>
        MOUSEEVENTF_VIRTUALDESK = 0x4000,
        /// <summary>
        /// The dx and dy members contain normalized absolute coordinates.
        ///  If the flag is not set, dxand dy contain relative data (the change in position since the last reported position).
        ///  This flag can be set, or not set, regardless of what kind of mouse or other pointing device,
        ///  if any, is connected to the system. For further information about relative mouse motion,
        ///  see the following Remarks section.
        /// </summary>
        MOUSEEVENTF_ABSOLUTE = 0x8000,
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct MOUSEINPUT
    {
        /// <summary>The absolute position of the mouse, or the amount of motion since the last mouse event was generated,
        /// depending on the value of the dwFlags member. Absolute data is specified as the x coordinate of the mouse; 
        /// relative data is specified as the number of pixels moved.
        /// </summary>
        public int dx;
        /// <summary>The absolute position of the mouse, or the amount of motion since the last mouse event was generated,
        /// depending on the value of the dwFlags member. Absolute data is specified as the y coordinate of the mouse;
        /// relative data is specified as the number of pixels moved.
        /// </summary>
        public int dy;
        /// <summary>
        /// A set of bit flags that specify various aspects of mouse motion and button clicks
        /// The bits in this member can be any reasonable combination of the following values.
        /// 
        /// The bit flags that specify mouse button status are set to indicate changes in status, not ongoing conditions.
        /// For example, if the left mouse button is pressed and held down,
        /// MOUSEEVENTF_LEFTDOWN is set when the left button is first pressed, but not for subsequent motions.
        /// Similarly MOUSEEVENTF_LEFTUP is set only when the button is first released.
        /// 
        /// You cannot specify both the MOUSEEVENTF_WHEEL flag and either MOUSEEVENTF_XDOWN or MOUSEEVENTF_XUP flags 
        /// simultaneously in the dwFlags parameter, because they both require use of the mouseData field.
        /// </summary>
        public int mouseData;
        /// <summary>The message generated by the input hardware.</summary>
        public MOUSEEVENTF dwFlags;
        /// <summary>The message generated by the input hardware.</summary>
        public uint time;
        /// <summary>The message generated by the input hardware.</summary>
        public IntPtr dwExtraInfo;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct KEYBDINPUT
    {
        public ushort wVk;
        public ushort wScan;
        public uint dwFlags;
        public uint time;
        public IntPtr dwExtraInfo;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct HARDWAREINPUT
    {
        /// <summary>The message generated by the input hardware.</summary>
        uint uMsg;
        /// <summary>The low-order word of the lParam parameter for uMsg.</summary>
        ushort wParamL;
        /// <summary>The high-order word of the lParam parameter for uMsg.</summary>
        ushort wParamH;
    }

    [StructLayout(LayoutKind.Explicit)]
    public struct INPUT
    {
        [FieldOffset(0)]
        public int type;
        /// <summary>The event is a mouse event. Use the mi structure of the union.</summary>
        [FieldOffset(4)]
        public MOUSEINPUT mi;
        /// <summary>The event is a keyboard event. Use the ki structure of the union.</summary>
        [FieldOffset(4)]
        public KEYBDINPUT ki;
        /// <summary>The event is a hardware event. Use the hi structure of the union.</summary>
        [FieldOffset(4)]
        public HARDWAREINPUT hi;
    }
    // https://www.pinvoke.net/default.aspx/Enums/HIDUsagePage.html
    public enum HIDUsagePage : ushort
    {
        ///<summary>Undefined Unknown usage page.</summary>
        UNDEFINED = 0x00,
        ///<summary>Generic desktop controls.</summary>
        GENERIC = 0x01,
        ///<summary>Simulation controls.</summary>
        SIMULATION = 0x02,
        ///<summary>Virtual reality controls.</summary>
        VR = 0x03,
        ///<summary>Sports controls.</summary>
        SPORT = 0x04,
        ///<summary>Games controls.</summary>
        GAME = 0x05,
        ///<summary>Keyboard controls.</summary>
        KEYBOARD = 0x07,
        ///<summary>LED controls.</summary>
        LED = 0x08,
        ///<summary>Button.</summary>
        BUTTON = 0x09,
        ///<summary>Ordinal.</summary>
        ORDINAL = 0x0A,
        ///<summary>Telephony.</summary>
        TELEPHONY = 0x0B,
        ///<summary>Consumer.</summary>
        CONSUMER = 0x0C,
        ///<summary>Digitizer.</summary>
        DIGITIZER = 0x0D,
        ///<summary>Physical interface device.</summary>
        PID = 0x0F,
        ///<summary>Unicode.</summary>
        UNICODE = 0x10,
        ///<summary>Alphanumeric display.</summary>
        ALPHA_NUMERIC = 0x14,
        ///<summary>Medical instruments.</summary>
        MEDICAL = 0x40,
        ///<summary>Monitor page 0.</summary>
        MONITOR_PAGE0 = 0x80,
        ///<summary>Monitor page 1.</summary>
        MONITOR_PAGE1 = 0x81,
        ///<summary>Monitor page 2.</summary>
        MONITOR_PAGE2 = 0x82,
        ///<summary>Monitor page 3.</summary>
        MONITOR_PAGE3 = 0x83,
        ///<summary>Power page 0.</summary>
        POWER_PAGE0 = 0x84,
        ///<summary>Power page 1.</summary>
        POWER_PAGE1 = 0x85,
        ///<summary>Power page 2.</summary>
        POWER_PAGE2 = 0x86,
        ///<summary>Power page 3.</summary>
        POWER_PAGE3 = 0x87,
        ///<summary>Bar code scanner.</summary>
        BARCODE = 0x8C,
        ///<summary>Scale page.</summary>
        SCALE = 0x8D,
        ///<summary>Magnetic strip reading devices.</summary>
        MSR = 0x8E
    }

    // https://www.pinvoke.net/default.aspx/Enums/HIDUsage.html
    public enum HIDUsage : ushort
    {
        ///<summary>Mouse Device</summary>
        MOUSE = 0x02,
        /// <summary>Keyboard Device</summary>
        KEYBOARD = 0x06,
    }

    // https://www.pinvoke.net/default.aspx/Enums/RawInputDeviceFlags.html
    [Flags()]
    public enum RawInputDeviceFlags
    {
        ///<summary>No flags.</summary>
        NONE = 0,
        ///<summary>If set, this removes the top level collection from the inclusion list. This tells the operating system to stop reading from a device which matches the top level collection.</summary>
        REMOVE = 0x00000001,
        ///<summary>If set, this specifies the top level collections to exclude when reading a complete usage page. This flag only affects a TLC whose usage page is already specified with PageOnly.</summary>
        EXCLUDE = 0x00000010,
        ///<summary>If set, this specifies all devices whose top level collection is from the specified usUsagePage. Note that Usage must be zero. To exclude a particular top level collection, use Exclude.</summary>
        PAGE_ONLY = 0x00000020,
        ///<summary>If set, this prevents any devices specified by UsagePage or Usage from generating legacy messages. This is only for the mouse and keyboard.</summary>
        NO_LEGACY = 0x00000030,
        ///<summary>If set, this enables the caller to receive the input even when the caller is not in the foreground. Note that WindowHandle must be specified.</summary>
        INPUT_SINK = 0x00000100,
        ///<summary>If set, the mouse button click does not activate the other window.</summary>
        CAPTURE_MOUSE = 0x00000200,
        ///<summary>If set, the application-defined keyboard device hotkeys are not handled. However, the system hotkeys; for example, ALT+TAB and CTRL+ALT+DEL, are still handled. By default, all keyboard hotkeys are handled. NoHotKeys can be specified even if NoLegacy is not specified and WindowHandle is NULL.
        ///If set, application keys are handled.  NoLegacy must be specified.  Keyboard only.</summary>
        APPKEYS = 0x00000400
    }

    // https://www.pinvoke.net/default.aspx/Structures.RAWINPUTDEVICE
    [StructLayout(LayoutKind.Sequential)]
    public struct RAWINPUTDEVICE
    {
        ///<summary>Top level collection Usage page for the raw input device.</summary>
        public HIDUsagePage usagePage;
        ///<summary>Top level collection Usage for the raw input device.</summary>
        public HIDUsage usage;
        ///<summary>Mode flag that specifies how to interpret the information provided by UsagePage and Usage.</summary>
        public RawInputDeviceFlags flags;
        ///<summary>Handle to the target device. If NULL, it follows the keyboard focus.</summary>
        public IntPtr windowHandle;
    }
    public enum RawInputType
    {
        ///<summary>Mouse input.</summary>
        MOUSE = 0,
        ///<summary>Keyboard input.</summary>
        KEYBOARD = 1,
        ///<summary>Another device that is not the keyboard or the mouse.</summary>
        HID = 2
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct RawInputHeader
    {
        ///<summary>Type of device the input is coming from..</summary>
        public RawInputType type;
        ///<summary>Size of the packet of data..</summary>
        public int size;
        ///<summary>Handle to the device sending the data..</summary>
        public IntPtr device;
        ///<summary>wParam from the window message..</summary>
        public int param;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct RawKeyboard
    {
        [MarshalAs(UnmanagedType.U2)]
        public ushort makeCode;
        [MarshalAs(UnmanagedType.U2)]
        public ushort flags;
        [MarshalAs(UnmanagedType.U2)]
        public ushort reserved;
        [MarshalAs(UnmanagedType.U2)]
        public ushort vkey;
        [MarshalAs(UnmanagedType.U4)]
        public uint message;
        [MarshalAs(UnmanagedType.U4)]
        public uint extraInformation;
    }

    [Flags()]
    public enum RawMouseButtons : ushort
    {
        ///<summary>No button..</summary>
        NONE = 0,
        ///<summary>Left (button 1) down..</summary>
        LEFT_DOWN = 0x0001,
        ///<summary>Left (button 1) up..</summary>
        LEFT_UP = 0x0002,
        ///<summary>Right (button 2) down..</summary>
        RIGHT_DOWN = 0x0004,
        ///<summary>Right (button 2) up..</summary>
        RIGHT_UP = 0x0008,
        ///<summary>Middle (button 3) down..</summary>
        MIDDLE_DOWN = 0x0010,
        ///<summary>Middle (button 3) up..</summary>
        MIDDLE_UP = 0x0020,
        ///<summary>Button 4 down..</summary>
        BUTTON4_DOWN = 0x0040,
        ///<summary>Button 4 up..</summary>
        BUTTON4_UP = 0x0080,
        ///<summary>Button 5 down..</summary>
        BUTTON5_DOWN = 0x0100,
        ///<summary>Button 5 up..</summary>
        BUTTON5_UP = 0x0200,
        ///<summary>Mouse wheel moved..</summary>
        MOUSE_WHELL = 0x0400
    }

    [Flags()]
    public enum RawMouseFlags : ushort
    {
        ///<summary>Relative to the last position.</summary>
        MOVE_RELATIVE = 0,
        ///<summary>Absolute positioning.</summary>
        MOVE_ABSOLUTE = 1,
        ///<summary>Coordinate data is mapped to a virtual desktop.</summary>
        VIRTUAL_DESKTOP = 2,
        ///<summary>Attributes for the mouse have changed.</summary>
        ATTRIBUTES_CHANGED = 4
    }

    [StructLayout(LayoutKind.Explicit)]
    public struct RawMouse
    {
        ///<summary>The mouse state.</summary>
        [FieldOffset(0)]
        public RawMouseFlags flags;
        ///<summary>Flags for the event.</summary>
        [FieldOffset(4)]
        public RawMouseButtons buttonFlags;
        ///<summary>If the mouse wheel is moved, this will contain the delta amount.</summary>
        [FieldOffset(6)]
        public ushort buttonData;
        ///<summary>Raw button data.</summary>
        [FieldOffset(8)]
        public uint rawButtons;
        ///<summary>The motion in the X direction. This is signed relative motion or 
        ///absolute motion, depending on the value of usFlags.</summary>
        [FieldOffset(12)]
        public int X;
        ///<summary>The motion in the Y direction. This is signed relative motion or absolute motion, 
        ///depending on the value of usFlags.</summary>
        [FieldOffset(16)]
        public int Y;
        ///<summary>The device-specific additional information for the event.</summary>
        [FieldOffset(20)]
        public uint extraInformation;
    }

    [StructLayout(LayoutKind.Explicit)]
    public struct RawInput32
    {
        ///<summary>Header for the data.</summary>
        [FieldOffset(0)]
        public RawInputHeader header;
        ///<summary>Mouse raw input data.</summary>
        [FieldOffset(16)]
        public RawMouse mouse;
        ///<summary>Keyboard raw input data.</summary>
        [FieldOffset(16)]
        public RawKeyboard keyboard;
        ///<summary>HID raw input data.</summary>
        [FieldOffset(16)]
        public RAWHID hid;
    }

    [StructLayout(LayoutKind.Explicit)]
    public struct RawInput64
    {
        ///<summary>Header for the data.</summary>
        [FieldOffset(0)]
        public RawInputHeader header;
        ///<summary>Mouse raw input data.</summary>
        [FieldOffset(24)]
        public RawMouse mouse;
        ///<summary>Keyboard raw input data.</summary>
        [FieldOffset(24)]
        public RawKeyboard keyboard;
        ///<summary>HID raw input data.</summary>
        [FieldOffset(24)]
        public RAWHID hid;
    }

    public class RawInput
    {
        private RawInput64 rawInput64;
        private RawInput32 rawInput32;

        public RawInput(RawInput64 rawObj)
        {
            this.rawInput64 = rawObj;
        }

        public RawInput(RawInput32 rawObj)
        {
            this.rawInput32 = rawObj;
        }

        public RawInputHeader Header
        {
            get
            {
                return (IntPtr.Size == 4) ? rawInput32.header : rawInput64.header;
            }
        }

        public RawMouse Mouse 
        { 
            get
            {
                return (IntPtr.Size == 4) ? rawInput32.mouse : rawInput64.mouse;
            }
        }
        public RawKeyboard Keyboard
        {
            get
            {
                return (IntPtr.Size == 4) ? rawInput32.keyboard : rawInput64.keyboard;
            }
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct RAWHID
    {
        [MarshalAs(UnmanagedType.U4)]
        public int sizHid;
        [MarshalAs(UnmanagedType.U4)]
        public int count;
    }
    static public class Win32
    {
        public const int RID_INPUT = 0x10000003;
        public const int RIDEV_INPUTSINK = 0x00000100;

        public const int WM_INPUT = 0x00FF;
        //public const int WM_LBUTTONDOWN = 0x0201;
        //public const int WM_RBUTTONDOWN = 0x0204;
        //public const int WM_PARENTNOTIFY = 0x210;

        public const int WM_IME_CONTROL = 0x283;

        public const int RIM_INPUT = 0;
        public const int RIM_INPUTSINK = 1;

        public const int VK_KEY_DOWN = 0x00000100;
        public const int VK_KEY_UP   = 0x00000101;

        public const int VK_KEY_LCTRL = 0x00000011;
        public const int VK_KEY_RCTRL = 0x00000019;

        public const int VK_KEY_LALT = 0x00000012;
        public const int VK_KEY_RALT = 0x00000015;

        public const int VK_KEY_SHIFT = 0x00000010;

        public const int INPUT_MOUSE = 0;
        public const int INPUT_KEYBOARD = 1;

        public const int SM_CXSCREEN = 0;
        public const int SM_CYSCREEN = 1;

        [DllImport("user32.dll")]
        public static extern bool RegisterRawInputDevices([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] RAWINPUTDEVICE[] pRawInputDevices, int uiNumDevices, int cbSize);

        [DllImport("User32.dll")]
        public static extern uint GetRawInputData(IntPtr hRawInput, uint uiCommand, IntPtr pData, ref uint pcbSize, uint cbSizeHeader);

        [DllImport("user32.dll")]
        public static extern uint SendInput(uint nInputs, INPUT[] inputs, int cbSize);
        [DllImport("user32.dll")]
        public static extern IntPtr GetForegroundWindow();

        [DllImport("user32.dll")]
        public static extern int GetSystemMetrics(int nIndex);

        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        public static extern IntPtr SendMessage(IntPtr hWnd, UInt32 Msg, IntPtr wParam, IntPtr IParam);
        
        [DllImport("imm32.dll")]
        public static extern IntPtr ImmGetDefaultIMEWnd(IntPtr hWnd);

        static public RawInput GetDeviceID(Message message)
        {
            uint size = 0;
            uint headerSize = (uint)Marshal.SizeOf(typeof(RawInputHeader));

            Win32.GetRawInputData(message.LParam, Win32.RID_INPUT, IntPtr.Zero, ref size, headerSize);
            IntPtr buffer = Marshal.AllocHGlobal((int)size);
            Win32.GetRawInputData(message.LParam, Win32.RID_INPUT, buffer, ref size, headerSize);

            RawInput rawInput;

            if (IntPtr.Size == 4)
            {
                var rawObject = Marshal.PtrToStructure(buffer, typeof(RawInput32));
                rawInput = new RawInput( (RawInput32)rawObject);
            }
            else
            {
                var rawObject = Marshal.PtrToStructure(buffer, typeof(RawInput64));
                rawInput = new RawInput( (RawInput64)rawObject);  
            }

            Marshal.FreeHGlobal(buffer);

            return rawInput;
        }
        static public bool isIMEStatus()
        {
            IntPtr topWindow = Win32.GetForegroundWindow();
            if (topWindow != IntPtr.Zero)
            {
                IntPtr ime = Win32.ImmGetDefaultIMEWnd(topWindow);
                if (ime != IntPtr.Zero)
                {
                    IntPtr status = SendMessage(ime, WM_IME_CONTROL, new IntPtr(0x5), new IntPtr(0));
                    return (status.ToInt32() != 0)? true : false;
                }
            }
            return false;
        }
        static public Point screenToMousePosition(Point point)
        {
            point.X = (point.X > 0) ?
                (int)((point.X + 0.5) * 65536.0/ GetSystemMetrics(SM_CXSCREEN)) :
                (int)((point.X - 0.5) * 65536.0/ GetSystemMetrics(SM_CXSCREEN));
            point.Y = (point.Y> 0) ?
                (int)((point.Y + 0.5) * 65536.0/ GetSystemMetrics(SM_CYSCREEN)) :
                (int)((point.Y - 0.5) * 65536.0/ GetSystemMetrics(SM_CYSCREEN));
            return point;
        }
    }
}